{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"World Engine \u00b6 Warning WorldEngine is currently in development. Things are subject to change.","title":"Home"},{"location":"#world-engine","text":"Warning WorldEngine is currently in development. Things are subject to change.","title":"World Engine"},{"location":"core/logger/","text":"class Logger \u00b6 Importing Using Require local Logger = require ( ReplicatedStorage . WorldEngine . Logger ) Using Import local Logger = import \"Logger\" The logger class is a superior way of logging out debugging information as opposed to the regular print , warn , assert and error . Using Logger \u00b6 There are two ways of using Logger . First is the global logger, calling methods on Logger itself... and creating a logger using Logger.new() and calling the methods off that. Methods of Logger \u00b6 Logger:Info(message: string, ...): void Prints out an info message, similar to print but is formatted with debugging information set by the Logger An example message from Logger:Info is [ReplicatedStorage.MyModule] Hello, World! InfoExample.lua Logger : Info ( \"Hello, World!\" ) will print out [Path.To.InfoExample] Hello, World! Logger:Warn(message: string, ...): void Prints out a warning message, similar to warn but is formatted with debugging information set by the Logger InfoWarning.lua Logger : Warn ( \"Hello, Warning!\" ) will display the warning: [Path.To.InfoWarning] Hello, Warning! Stack information will also be displayed if warningsWithStackTrace is set to true Logger:Error(message: string, ...): never Displays an error, similar to error but is formatted with debugging information set by Logger InfoError.lua Logger : Error ( \"Hello, Error!\" ) will display the warning: [Path.To.InfoError] Hello, Error! Logger:AssertTrue(condition?: boolean, message: string, ...): any Displays an error if the condition is falsy ( false , nil ), similar to assert but is formatted with debugging information set by the logger AssertExampleFalse.lua Logger : AssertTrue ( false , \"Failed!\" ) Will print out [Path.To.AssertExampleFalse] Failed! Logger:Format(message: string, ...): string Will format a message with the logger's format. Used internally by the methods in Logger . FormatExample.lua local result = Logger : Format ( \"Hello, {1}!\" , \"World\" ) print ( result ) output will be [Path.To.FormatExample] Hello, World!","title":"Logger"},{"location":"core/logger/#class-logger","text":"Importing Using Require local Logger = require ( ReplicatedStorage . WorldEngine . Logger ) Using Import local Logger = import \"Logger\" The logger class is a superior way of logging out debugging information as opposed to the regular print , warn , assert and error .","title":"class Logger"},{"location":"core/logger/#using-logger","text":"There are two ways of using Logger . First is the global logger, calling methods on Logger itself... and creating a logger using Logger.new() and calling the methods off that.","title":"Using Logger"},{"location":"core/logger/#methods-of-logger","text":"Logger:Info(message: string, ...): void Prints out an info message, similar to print but is formatted with debugging information set by the Logger An example message from Logger:Info is [ReplicatedStorage.MyModule] Hello, World! InfoExample.lua Logger : Info ( \"Hello, World!\" ) will print out [Path.To.InfoExample] Hello, World! Logger:Warn(message: string, ...): void Prints out a warning message, similar to warn but is formatted with debugging information set by the Logger InfoWarning.lua Logger : Warn ( \"Hello, Warning!\" ) will display the warning: [Path.To.InfoWarning] Hello, Warning! Stack information will also be displayed if warningsWithStackTrace is set to true Logger:Error(message: string, ...): never Displays an error, similar to error but is formatted with debugging information set by Logger InfoError.lua Logger : Error ( \"Hello, Error!\" ) will display the warning: [Path.To.InfoError] Hello, Error! Logger:AssertTrue(condition?: boolean, message: string, ...): any Displays an error if the condition is falsy ( false , nil ), similar to assert but is formatted with debugging information set by the logger AssertExampleFalse.lua Logger : AssertTrue ( false , \"Failed!\" ) Will print out [Path.To.AssertExampleFalse] Failed! Logger:Format(message: string, ...): string Will format a message with the logger's format. Used internally by the methods in Logger . FormatExample.lua local result = Logger : Format ( \"Hello, {1}!\" , \"World\" ) print ( result ) output will be [Path.To.FormatExample] Hello, World!","title":"Methods of Logger"},{"location":"core/object/","text":"Classes in WorldEngine \u00b6 Classes in WorldEngine use the core Object library. Importing Using Require local Object = require ( ReplicatedStorage . WorldEngine . Object ) Using Import local Object = import \"Object\" Class Creation \u00b6 Creating a class in WorldEngine is simply the following: local MyClass = Object : Extend ( \"MyClass\" ) function MyClass : constructor () end This is similar to the Roact syntax for classes. An object of MyClass then can be created via MyClass . new () Object Creation Calling .new() will pass any arguments to :constructor() , you can then assign properties using self in constructor . Example class \u00b6 -- The import library is the easiest way to import multiple files local import = require ( game : GetService ( \"ReplicatedStorage\" ) : WaitForChild ( \"WorldEngine\" ) : WaitForChild ( \"Import\" )) local Object = import \"Object\" local t = import \"t\" -- type check local MyClass = Object : Extend ( \"MyClass\" ) function MyClass : constructor ( name ) assert ( t . string ( name )) -- enforce name = typeof string self . _name = name end function MyClass : GetName () return self . _name end local myObject = MyClass . new ( \"Bob\" ) print ( myObject : GetName ()) -- will print \"Bob\" return MyClass You can also extend other objects like such (presuming MyClass is in the same directory as MySubClass ) local import = require ( game : GetService ( \"ReplicatedStorage\" ) : WaitForChild ( \"WorldEngine\" ) : WaitForChild ( \"Import\" )) local t = import \"t\" local MyClass = import \"../MyClass\" local MySubClass = MyClass : Extend ( \"MySubClass\" ) function MySubClass : constructor ( name , age ) MyClass : super ( self , name ) -- This will call the parent constructor assert ( t . number ( age )) self . _age = age end function MySubClass : GetAge () return self . _age end local mySubObject = MySubClass . new ( \"David\" , 20 ) print ( mySubObject : GetName (), mySubObject : GetAge ()) -- will print David 20 return MySubClass Class Modifiers \u00b6 The Extend method of Objects also has a second parameter, which is the modifiers parameter. Below are a list of those parameters. Abstract \u00b6 Sometimes you don't want a base class to be createable, which is easy. local MyClass = Object : Extend ( \"MyClass\" , { abstract = true }) function MyClass : constructor () -- ... end -- The following will error, you have to create a sub class! local myObject = MyObject . new () Sealed \u00b6 Sometimes you don't want your class to be able to be extended. This is where Sealed comes in handy. local MyClass = Object : Extend ( \"MyClass\" , { sealed = true }) function MyClass : constructor () -- ... end -- The following will error, sealed classes can't be inherited! local MySubClass = MyClass : Extend ( \"MySubClass\" )","title":"Classes"},{"location":"core/object/#classes-in-worldengine","text":"Classes in WorldEngine use the core Object library. Importing Using Require local Object = require ( ReplicatedStorage . WorldEngine . Object ) Using Import local Object = import \"Object\"","title":"Classes in WorldEngine"},{"location":"core/object/#class-creation","text":"Creating a class in WorldEngine is simply the following: local MyClass = Object : Extend ( \"MyClass\" ) function MyClass : constructor () end This is similar to the Roact syntax for classes. An object of MyClass then can be created via MyClass . new () Object Creation Calling .new() will pass any arguments to :constructor() , you can then assign properties using self in constructor .","title":"Class Creation"},{"location":"core/object/#example-class","text":"-- The import library is the easiest way to import multiple files local import = require ( game : GetService ( \"ReplicatedStorage\" ) : WaitForChild ( \"WorldEngine\" ) : WaitForChild ( \"Import\" )) local Object = import \"Object\" local t = import \"t\" -- type check local MyClass = Object : Extend ( \"MyClass\" ) function MyClass : constructor ( name ) assert ( t . string ( name )) -- enforce name = typeof string self . _name = name end function MyClass : GetName () return self . _name end local myObject = MyClass . new ( \"Bob\" ) print ( myObject : GetName ()) -- will print \"Bob\" return MyClass You can also extend other objects like such (presuming MyClass is in the same directory as MySubClass ) local import = require ( game : GetService ( \"ReplicatedStorage\" ) : WaitForChild ( \"WorldEngine\" ) : WaitForChild ( \"Import\" )) local t = import \"t\" local MyClass = import \"../MyClass\" local MySubClass = MyClass : Extend ( \"MySubClass\" ) function MySubClass : constructor ( name , age ) MyClass : super ( self , name ) -- This will call the parent constructor assert ( t . number ( age )) self . _age = age end function MySubClass : GetAge () return self . _age end local mySubObject = MySubClass . new ( \"David\" , 20 ) print ( mySubObject : GetName (), mySubObject : GetAge ()) -- will print David 20 return MySubClass","title":"Example class"},{"location":"core/object/#class-modifiers","text":"The Extend method of Objects also has a second parameter, which is the modifiers parameter. Below are a list of those parameters.","title":"Class Modifiers"},{"location":"core/object/#abstract","text":"Sometimes you don't want a base class to be createable, which is easy. local MyClass = Object : Extend ( \"MyClass\" , { abstract = true }) function MyClass : constructor () -- ... end -- The following will error, you have to create a sub class! local myObject = MyObject . new ()","title":"Abstract"},{"location":"core/object/#sealed","text":"Sometimes you don't want your class to be able to be extended. This is where Sealed comes in handy. local MyClass = Object : Extend ( \"MyClass\" , { sealed = true }) function MyClass : constructor () -- ... end -- The following will error, sealed classes can't be inherited! local MySubClass = MyClass : Extend ( \"MySubClass\" )","title":"Sealed"},{"location":"entity/","text":"Entities \u00b6 Entities in WorldEngine","title":"Entity"},{"location":"entity/#entities","text":"Entities in WorldEngine","title":"Entities"}]}